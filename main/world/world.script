local config = require "modules.config"
local globals = require "modules.globals"
local helpers = require "modules.helpers"
local camera_constants = require "modules.constants.camera"
local item_constants = require "modules.constants.items"
local message_constants = require "modules.constants.messages"
local noise = require "modules.noise"
local orthographic = require "orthographic.camera"
local position_helpers = require "modules.position_helpers"
local urls = require "modules.urls"
local world_constants = require "modules.constants.world"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"
require "modules.set"

world = {}
worldMutation = {
	chunks = {}
}

-------------
-- Helpers --
-------------

local create_block
local create_loose_pickup
local fill_world
local initialize_new_world
local generate_world
local initialize_world_chunks
local mine_block
local mutate_world

function create_block(self, block, addToMutation)
	local truePosition = position_helpers.block_to_screen_position(block)
	local rotation = nil
	local properties = {}
	local scale = 1.0

	if truePosition then
		local factoryBlock = factory.create(urls.get_factory_url(block.id), truePosition, rotation, properties, scale)
		block.url = factoryBlock
		block.durability = item_constants.ALL_ITEMS[block.id].maxDurability
		local blockChunk = World.get_chunk_at_position(world, block.chunk)
		if blockChunk then
			Chunk.add_block(blockChunk, block)
		end

		if addToMutation then
			local mutatedChunk = nil
			if worldMutation.chunks[blockChunk.position.x] == nil then
				worldMutation.chunks[blockChunk.position.x] = {}
			end
			if worldMutation.chunks[blockChunk.position.x][blockChunk.position.y] == nil then
				mutatedChunk = {
					position = { x = blockChunk.position.x, y = blockChunk.position.y, z = blockChunk.position.z },
					blocks = {}
				}
				worldMutation.chunks[blockChunk.position.x][blockChunk.position.y] = mutatedChunk
			else
				mutatedChunk = worldMutation.chunks[blockChunk.position.x][blockChunk.position.y]
			end
			if mutatedChunk.blocks[block.position.x] == nil then
				mutatedChunk.blocks[block.position.x] = {}
			end
			local mutatedBlock = {
				position = { x = block.position.x, y = block.position.y, z = block.position.z },
				id = block.id
			}
			mutatedChunk.blocks[block.position.x][block.position.y] = mutatedBlock
		end

		return true
	else
		return false
	end
end

function create_loose_pickup(item, position)
	local rotation = nil
	local properties = {}
	local scale = 0.5

	local loosePickupId = factory.create(urls.get_pickup_factory_url(item.id), position, rotation, properties, scale)
	item.pickupId = loosePickupId
	World.add_loose_pickup(world, item)
end

function fill_world(self)
	if globals.currentChunk then
		local chunksToRender = {}
		local chunksToUnrender = {}
		for chunkX = globals.currentChunk.position.x - world_constants.RENDER_DISTANCE.x, globals.currentChunk.position.x + world_constants.RENDER_DISTANCE.x do
			for chunkY = globals.currentChunk.position.y - world_constants.RENDER_DISTANCE.y, globals.currentChunk.position.y + world_constants.RENDER_DISTANCE.y do
				local chunkPosition = vmath.vector3(chunkX, chunkY, 0)
				chunksToRender[tostring(chunkPosition)] = chunkPosition
			end
		end
		if globals.previousChunk then
			for chunkX = globals.previousChunk.position.x - world_constants.RENDER_DISTANCE.x, globals.previousChunk.position.x + world_constants.RENDER_DISTANCE.x do
				for chunkY = globals.previousChunk.position.y - world_constants.RENDER_DISTANCE.y, globals.previousChunk.position.y + world_constants.RENDER_DISTANCE.y do
					local chunkPosition = vmath.vector3(chunkX, chunkY, 0)
					chunksToUnrender[tostring(chunkPosition)] = chunkPosition
				end
			end
			local unrenderLookup = Set.subtraction(chunksToUnrender, chunksToRender, "position")

			for i, chunkPosition in pairs(chunksToUnrender) do
				if unrenderLookup[tostring(chunkPosition)] then
					local chunkToUnrender = World.get_chunk_at_position(world, chunkPosition)
					if chunkToUnrender then
						for blockX, blockXColumn in pairs(chunkToUnrender.blocks) do
							for blockY, _ in pairs(blockXColumn) do
								local blockToDelete = Chunk.get_block_at_position(chunkToUnrender, vmath.vector3(blockX, blockY, 0))
								if blockToDelete and blockToDelete.url then
									go.delete(blockToDelete.url)
								end
							end
						end
						chunkToUnrender.isRendered = false
					end
				end
			end
		end

		for i, chunkPosition in pairs(chunksToRender) do
			local chunkToRender = World.get_chunk_at_position(world, chunkPosition)
			if chunkToRender and not chunkToRender.isRendered then
				for blockX, blockXColumn in pairs(chunkToRender.blocks) do
					for blockY, block in pairs(blockXColumn) do
						create_block(self, block)
					end
				end
				chunkToRender.isRendered = true
			end
		end
	end
end

function generate_world(worldSeed)
	local NOISE_SCALE = {
		x = 0.1,
		y = 0.1
	}
	local NOISE_OFFSET = {
		x = 20,
		y = 30
	}
	local NOISE_RANGE = {
		x = world_constants.WORLD_SIZE.x * world_constants.CHUNK_SIZE,
		y = world_constants.WORLD_SIZE.y * world_constants.CHUNK_SIZE
	}
	local NOISE_DENOMINATOR = {
		x = NOISE_RANGE.x * NOISE_SCALE.x + NOISE_OFFSET.x,
		y = NOISE_RANGE.y * NOISE_SCALE.y + NOISE_OFFSET.y
	}
	noise.shuffle_permutation(worldSeed)
	for chunkX, chunkXColumn in pairs(world.chunks) do
		-- Keep world from not rendering when you go out of the bounds
		if chunkX > -world_constants.WORLD_SIZE.x + world_constants.RENDER_DISTANCE.x and chunkX < world_constants.WORLD_SIZE.x - world_constants.RENDER_DISTANCE.x then
			for chunkY, chunk in pairs(chunkXColumn) do
				for y = 0, world_constants.CHUNK_SIZE - 1 do
					for x = 0, world_constants.CHUNK_SIZE - 1 do
						if chunkY <= 0 then
							local blockInfo = nil
							local worldX = x + (chunkX * world_constants.CHUNK_SIZE)
							local worldY = y + (chunkY * world_constants.CHUNK_SIZE)
							
							local noiseNumber = noise.Noise2D(worldX / NOISE_DENOMINATOR.x, worldY / NOISE_DENOMINATOR.y)
							noiseNumber = noiseNumber + 1

							if noiseNumber < 1.7 then
								if noiseNumber > 1.3 then
									blockInfo = item_constants.DIRT
								elseif noiseNumber > 1.0 then
									blockInfo = item_constants.SAND
								elseif noiseNumber > 0.7 then
									blockInfo = item_constants.CLAY
								elseif noiseNumber > 0.4 then
									blockInfo = item_constants.STONE
								elseif noiseNumber > 0.3 then
									blockInfo = item_constants.IRON_ORE
								elseif noiseNumber > 0.2 then
									blockInfo = item_constants.SILVER_ORE
								elseif noiseNumber > 0.1 then
									blockInfo = item_constants.GOLD_ORE
								elseif noiseNumber > 0 then
									blockInfo = item_constants.PLATINUM_ORE
								end
							end
							if blockInfo then
								local blockToInsert = {}
								blockToInsert.id = blockInfo.id
								blockToInsert.position = vmath.vector3(x, y, 0)

								Chunk.add_block(chunk, blockToInsert)
							end
						end
					end
				end
			end
		end
	end
end

function initialize_world_chunks()
	for x = -world_constants.WORLD_SIZE.x, world_constants.WORLD_SIZE.x do
		for y = -world_constants.WORLD_SIZE.y, world_constants.WORLD_SIZE.y do
			local chunkToAdd = {}
			chunkToAdd.blocks = {}
			chunkToAdd.position = vmath.vector3(x, y, 0)

			World.add_chunk(world, chunkToAdd)
		end
	end
end

function mine_block(blockUrl, message, chunkPosition, blockPosition)
	local screenPosition = vmath.vector3(message.screen_x, message.screen_y, 0)

	local chunk = World.get_chunk_at_position(world, chunkPosition)
	local block = Chunk.get_block_at_position(chunk, blockPosition)
	block.durability = block.durability - message.miningPower

	if block.durability <= 0 then
		go.delete(blockUrl)
		local truePosition = position_helpers.block_to_screen_position(block)
		truePosition.x = truePosition.x + math.random(-8, 8)
		create_loose_pickup(block, truePosition)

		local mutatedChunk = nil
		if worldMutation.chunks[chunk.position.x] == nil then
			worldMutation.chunks[chunk.position.x] = {}
		end
		if worldMutation.chunks[chunk.position.x][chunk.position.y] == nil then
			mutatedChunk = {
				position = { x = chunk.position.x, y = chunk.position.y, z = chunk.position.z },
				blocks = {}
			}
			worldMutation.chunks[chunk.position.x][chunk.position.y] = mutatedChunk
		else
			mutatedChunk = worldMutation.chunks[chunk.position.x][chunk.position.y]
		end
		if mutatedChunk.blocks[block.position.x] == nil then
			mutatedChunk.blocks[block.position.x] = {}
		end
		mutatedChunk.blocks[block.position.x][block.position.y] = {}

		Chunk.remove_block_at_position(chunk, blockPosition)
	end
end

function mutate_world(worldMutation)
	for chunkX, chunkXColumn in pairs(worldMutation.chunks) do
		for chunkY, chunk in pairs(chunkXColumn) do
			local worldChunk = World.get_chunk_at_position(world, chunk.position)

			for blockX, blockXColumn in pairs(chunk.blocks) do
				for blockY, block in pairs(blockXColumn) do
					if block.position == nil then
						Chunk.remove_block_at_position(worldChunk, { x = blockX, y = blockY })
					else
						local blockToAdd = { position = vmath.vector3(blockX, blockY, 0), id = block.id, chunk = vmath.vector3(chunkX, chunkY, 0) }
						Chunk.add_block(worldChunk, blockToAdd)
					end
				end
			end
		end
	end
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_create_loose_pickup
local handle_mine_block
local handle_place_block
local handle_update_chunk_render

function handle_create_loose_pickup(self, messageId, message, sender)
	create_loose_pickup(message.item, message.position)
end

function handle_mine_block(self, messageId, message, sender)
	local screenPosition = vmath.vector3(message.screen_x, message.screen_y, 0)
	local blockPosition = position_helpers.screen_to_block_position(screenPosition)
	local chunkPosition = position_helpers.screen_to_chunk_position(screenPosition)
	local chunk = World.get_chunk_at_position(world, chunkPosition)
	if chunk then
		local block = Chunk.get_block_at_position(chunk, blockPosition)
		if block then
			mine_block(block.url, message, chunkPosition, blockPosition)
		end
	end
end

function handle_place_block(self, messageId, message, sender)
	local toolbarItem = message.toolbarItem
	if toolbarItem and toolbarItem.id ~= item_constants.NONE.id then
		local messagePosition = vmath.vector3(message.screen_x, message.screen_y, 0)
		local chunkPosition = position_helpers.screen_to_chunk_position(messagePosition)
		local chunk = World.get_chunk_at_position(world, chunkPosition)
		if chunk then
			local blockPosition = position_helpers.screen_to_block_position(messagePosition)
			if not Chunk.get_block_at_position(chunk, blockPosition) then
				local block = {
					chunk = chunk.position,
					id = toolbarItem.id,
					position = blockPosition
				}
				if create_block(self, block, true) then
					toolbarItem.count = toolbarItem.count - 1
					msg.post("/player#player_script", message_constants.UPDATE_TOOLBAR_ITEM, toolbarItem)
				end
			end
		end
	end
end

function handle_update_chunk_render(self, messageId, message, sender)
	fill_world(self)
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	msg.post("@render:", "clear_color", { color = vmath.vector4(0.6, 0.5, 0.9, 1.0) })
	local savedWorld = helpers.load_game(globals.saveFileName)
	if savedWorld then
		if savedWorld.seed then
			world_constants.SEED = savedWorld.seed
		else
			print("There was no world seed in the save file")
		end
		if savedWorld.scale then
			world_constants.SCALE = savedWorld.scale
		else
			print("There was no world scale in the save file")
		end
	else
		world_constants.SEED = os.time()
	end

	worldMutation.seed = world_constants.SEED
	worldMutation.scale = world_constants.SCALE

	local worldScale = world_constants.SCALES[string.upper(worldMutation.scale)]
	world_constants.WORLD_SIZE.x = world_constants.BASE_WORLD_SIZE.x * worldScale
	world_constants.WORLD_SIZE.y = world_constants.BASE_WORLD_SIZE.y
	initialize_world_chunks()
	generate_world(world_constants.SEED)

	if savedWorld and savedWorld.chunks then
		worldMutation = savedWorld
		mutate_world(worldMutation)
	end
	fill_world(self)
end

function on_message(self, messageId, message, sender)
	if messageId == message_constants.CREATE_LOOSE_PICKUP then
		handle_create_loose_pickup(self, messageId, message, sender)
	elseif messageId == message_constants.MINE_BLOCK then
		handle_mine_block(self, messageId, message, sender)
	elseif messageId == message_constants.PLACE_BLOCK then
		handle_place_block(self, messageId, message, sender)
	elseif messageId == message_constants.UPDATE_CHUNK_RENDER then
		handle_update_chunk_render(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------