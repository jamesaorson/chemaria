local globals = require "modules.globals"
local item_constants = require "modules.constants.items"
local orthographic = require "orthographic.camera"
local position_helpers = require "modules.position_helpers"
local urls = require "modules.urls"
local world_constants = require "modules.constants.world"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"

world = {}

-------------
-- Helpers --
-------------

local create_block
local create_blocks_from_world
local mine_block
local get_saved_world
local initialize_from_saved_world
local initialize_new_world
local initialize_world_chunks

function create_block(self, block)
	local truePosition = position_helpers.block_to_screen_position(block)
	local rotation = nil
	local properties = {}
	local scale = 1.0

	if truePosition then
		local factoryBlock = factory.create(urls.get_factory_url(block.id), truePosition, rotation, properties, scale)
		block.url = factoryBlock
		local blockChunk = World.get_chunk_at_position(world, block.chunk)
		if blockChunk then
			Chunk.add_block(blockChunk, block)
		end

		return true
	else
		return false
	end
end

function create_blocks_from_world(self)
	for i, chunkToRender in pairs(world.chunks) do
		chunkToRender = chunkToRender[0]
		if chunkToRender then
			for blockX, blockXColumn in pairs(chunkToRender.blocks) do
				for blockY, block in pairs(blockXColumn) do
					create_block(self, block)
				end
			end
		end
	end
end

function mine_block(blockUrl, message)
	go.delete(blockUrl)
end

function initialize_new_world()
	for chunkX, chunkXColumn in pairs(world.chunks) do
		for chunkY, chunk in pairs(chunkXColumn) do
			local blockInfo = item_constants.DIRT
			for y = 0, world_constants.CHUNK_SIZE - 1 do
				for x = 0, world_constants.CHUNK_SIZE - 1 do
					local blockToInsert = {}
					blockToInsert.id = blockInfo.id
					blockToInsert.position = vmath.vector3(x, y, 0)
					blockToInsert.type = blockInfo.type
					
					Chunk.add_block(chunk, blockToInsert)
				end
			end
		end
	end
end

function initialize_world_chunks()
	for x = -world_constants.WORLD_DIMENSIONS.x, world_constants.WORLD_DIMENSIONS.x do
		for y = -world_constants.WORLD_DIMENSIONS.y, world_constants.WORLD_DIMENSIONS.y do
			local chunkToAdd = {}
			chunkToAdd.blocks = {}
			chunkToAdd.position = vmath.vector3(x, y, 0)

			World.add_chunk(world, chunkToAdd)
		end
	end
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_mine_block

function handle_mine_block(self, messageId, message, sender)
	local screenPosition = vmath.vector3(message.screen_x, message.screen_y, 0)
	local miningBlockPosition = position_helpers.screen_to_block_position(screenPosition)
	local miningChunkPosition = position_helpers.screen_to_chunk_position(screenPosition)
	local chunk = World.get_chunk_at_position(world, miningChunkPosition)
	if chunk then
		local block = Chunk.get_block_at_position(chunk, miningBlockPosition)
		if block then
			mine_block(block.url, message)
			Chunk.remove_block_at_position(chunk, miningBlockPosition)
		end
	end
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	msg.post("@render:", "clear_color", { color = vmath.vector4(0, 0, 0, 1.0) })
	initialize_world_chunks()
	initialize_new_world()
	create_blocks_from_world(self)
end

function on_message(self, messageId, message, sender)
	if messageId == hash("mine_block") then
		handle_mine_block(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------