local constants = require "modules.constants"
local urls = require "modules.urls"
local rendercam = require "rendercam.rendercam"
local goput = require "modules.goput"
local positionHelpers = require "modules.positionHelpers"

require "modules.models.Block"
require "modules.models.Chunk"

function init(self)
	local dirtChunks = {}
	local stoneChunks = {}

	-- Dirt chunks
	for i = 0, 0 do
		local chunkToInsert = Chunk:new()
		chunkToInsert.origin = vmath.vector3(i * constants.CHUNK_SIZE, 0, 0)
		table.insert(dirtChunks, chunkToInsert)
	end

	for chunkIndex, chunk in ipairs(dirtChunks) do
		for y = -1, -constants.CHUNK_SIZE, -1 do
			for x = 1, constants.CHUNK_SIZE do
				local blockToInsert = Block:new()
				blockToInsert.position = vmath.vector3(chunk.origin.x + x, chunk.origin.y + y, 0)
				blockToInsert.type = "dirt"
				chunk:add_block(blockToInsert)
			end
		end
	end
	
	-- Stone chunks
	for i = 0, 3 do
		local chunkToInsert = Chunk:new()
		chunkToInsert.origin = vmath.vector3(i * constants.CHUNK_SIZE, -12, 0)
		table.insert(stoneChunks, chunkToInsert)
	end
	
	for chunkIndex, chunk in ipairs(stoneChunks) do
		for y = -1, -constants.CHUNK_SIZE, -1 do
			for x = 1, constants.CHUNK_SIZE do
				local blockToInsert = Block:new()
				blockToInsert.position = vmath.vector3(chunk.origin.x + x, chunk.origin.y + y, 0)
				blockToInsert.type = "stone"
				chunk:add_block(blockToInsert)
			end
		end
	end

	self.chunks = {}

	for i, dirtChunk in ipairs(dirtChunks) do
		table.insert(self.chunks, dirtChunk)
	end
	for i, stoneChunk in ipairs(stoneChunks) do
		table.insert(self.chunks, stoneChunk)
	end

	for i, chunk in pairs(self.chunks) do
		for j, xRow in pairs(chunk.blocks) do
			local blockColumn = chunk.blocks[j]
			for k, block in pairs(blockColumn) do
				create_block(self, block)
			end
		end
	end
end

function on_message(self, messageId, message, sender)
	if messageId == hash("mine_block") then
		local miningPosition = rendercam.screen_to_world_2d(message.screen_x, message.screen_y)
		message.x = miningPosition.x
		message.y = miningPosition.y
		goput.on_input(messageId, message)
	elseif messageId == hash("place_block") and message.pressed then
		local toolbarItem = message.toolbarItem
		if toolbarItem and toolbarItem.type ~= "empty" then
			local block = {
				position = positionHelpers.screen_to_block_position(vmath.vector3(message.x, message.y, 0)),
				type = toolbarItem.type
			}
			if create_block(self, block) then
				toolbarItem.count = toolbarItem.count - 1
				msg.post("/player#player_script", "update_toolbar_item", toolbarItem)
			end
		end
	end
end

function create_block(self, block)
	local truePosition = block.position * 32

	local rotation = nil
	local properties = {}
	local scale = 1.0
	
	block = factory.create(urls.get_factory_url(block.type), truePosition, rotation, properties, scale)
	local blockSpriteUrl = msg.url(block)
	blockSpriteUrl = urls.url_hash_to_string(blockSpriteUrl) .. "#sprite"
	goput.add(blockSpriteUrl, nil, mine_block)

	return true
end

function mine_block(url, actionId, action)
	local blockSpriteUrl = urls.url_hash_to_string(url) .. "#sprite"
	goput.remove(blockSpriteUrl)
	go.delete(url)
end