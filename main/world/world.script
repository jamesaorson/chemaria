local constants = require "modules.constants"
local urls = require "modules.urls"
local rendercam = require "rendercam.rendercam"
local goput = require "modules.goput"
local position_helpers = require "modules.position_helpers"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"

function init(self)
	self.world = World:new()
	local dirtChunks = {}
	local stoneChunks = {}

	-- Dirt chunks
	for i = 0, 3 do
		local chunkToInsert = Chunk:new()
		chunkToInsert.position = vmath.vector3(i, 0, 0)
		table.insert(dirtChunks, chunkToInsert)
	end

	for chunkIndex, chunk in pairs(dirtChunks) do
		for y = 0, constants.CHUNK_SIZE - 1 do
			for x = 0, constants.CHUNK_SIZE - 1 do
				local blockToInsert = Block:new()
				blockToInsert.chunk = chunk
				blockToInsert.position = vmath.vector3(x, -y, 0)
				blockToInsert.type = "dirt"
				chunk:add_block(blockToInsert)
			end
		end
	end
	
	-- Stone chunks
	for i = 0, 3 do
		local chunkToInsert = Chunk:new()
		chunkToInsert.position = vmath.vector3(i, -1, 0)
		table.insert(stoneChunks, chunkToInsert)
	end
	
	for chunkIndex, chunk in pairs(stoneChunks) do
		for y = 0, constants.CHUNK_SIZE - 1 do
			for x = 0, constants.CHUNK_SIZE - 1 do
				local blockToInsert = Block:new()
				blockToInsert.chunk = chunk
				blockToInsert.position = vmath.vector3(x, -y, 0)
				blockToInsert.type = "stone"
				chunk:add_block(blockToInsert)
			end
		end
	end

	for i, dirtChunk in pairs(dirtChunks) do
		self.world:add_chunk(dirtChunk)
	end
	for i, stoneChunk in pairs(stoneChunks) do
		self.world:add_chunk(stoneChunk)
	end

	for chunkX, chunk in pairs(self.world.chunks) do
		for chunkY, chunkXColumn in pairs(chunk) do
			for i, blocks in pairs(chunkXColumn) do
				for blockX, blockXColumn in pairs(blocks) do
					for blockY, block in pairs(blockXColumn) do
						create_block(self, block)
					end
				end
			end
		end
	end
end

function on_message(self, messageId, message, sender)
	if messageId == hash("mine_block") then
		local miningPosition = rendercam.screen_to_world_2d(message.screen_x, message.screen_y)
		message.x = miningPosition.x
		message.y = miningPosition.y
		goput.on_input(messageId, message)
	elseif messageId == hash("place_block") and message.pressed then
		local toolbarItem = message.toolbarItem
		if toolbarItem and toolbarItem.type ~= "empty" then
			local chunkPosition = position_helpers.screen_to_chunk_position(vmath.vector3(message.x, message.y, 0))
			local block = {
				position = position_helpers.screen_to_block_position(vmath.vector3(message.x, message.y, 0)),
				type = toolbarItem.type
			}
			if create_block(self, block) then
				toolbarItem.count = toolbarItem.count - 1
				msg.post("/player#player_script", "update_toolbar_item", toolbarItem)
			end
		end
	end
end

function create_block(self, block)
	pprint(block)
	local truePosition = vmath.vector3(block.position.x + (block.chunk.position.x) * constants.CHUNK_SIZE, block.position.y + (block.chunk.position.y) * 12, 0) * constants.BLOCK_SIZE

	local rotation = nil
	local properties = {}
	local scale = 1.0
	
	block = factory.create(urls.get_factory_url(block.type), truePosition, rotation, properties, scale)
	local blockSpriteUrl = msg.url(block)
	blockSpriteUrl = urls.url_hash_to_string(blockSpriteUrl) .. "#sprite"
	goput.add(blockSpriteUrl, nil, mine_block)

	return true
end

function mine_block(url, actionId, action)
	local blockSpriteUrl = urls.url_hash_to_string(url) .. "#sprite"
	goput.remove(blockSpriteUrl)
	go.delete(url)
end