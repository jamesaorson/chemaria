local config = require "modules.config"
local globals = require "modules.globals"
local item_constants = require "modules.constants.items"
local json_lib = require "modules.json_lib"
local orthographic = require "orthographic.camera"
local position_helpers = require "modules.position_helpers"
local urls = require "modules.urls"
local world_generation_constants = require "modules.constants.world_generation"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"
require "modules.set"

world = {}

-------------
-- Helpers --
-------------

local create_block
local create_blocks_from_world
local mine_block
local get_saved_world
local initialize_from_saved_world
local initialize_new_world
local initialize_world_chunks

function create_block(self, block)
	local truePosition = position_helpers.block_to_screen_position(block)
	local rotation = nil
	local properties = {}
	local scale = 1.0

	if truePosition then
		local factoryBlock = factory.create(urls.get_factory_url(block.id), truePosition, rotation, properties, scale)
		block.url = factoryBlock
		local blockChunk = World.get_chunk_at_position(world, block.chunk)
		if blockChunk then
			Chunk.add_block(blockChunk, block)
		end

		return true
	else
		return false
	end
end

function create_blocks_from_world(self)
	if globals.currentChunk then
		local chunksToRender = {}
		local chunksToUnrender = {}
		for chunkX = globals.currentChunk.position.x - world_generation_constants.RENDER_DISTANCE, globals.currentChunk.position.x + world_generation_constants.RENDER_DISTANCE do
			for chunkY = globals.currentChunk.position.y - world_generation_constants.RENDER_DISTANCE, globals.currentChunk.position.y + world_generation_constants.RENDER_DISTANCE do
				local chunkPosition = vmath.vector3(chunkX, chunkY, 0)
				chunksToRender[tostring(chunkPosition)] = chunkPosition
			end
		end
		if globals.previousChunk then
			for chunkX = globals.previousChunk.position.x - world_generation_constants.RENDER_DISTANCE, globals.previousChunk.position.x + world_generation_constants.RENDER_DISTANCE do
				for chunkY = globals.previousChunk.position.y - world_generation_constants.RENDER_DISTANCE, globals.previousChunk.position.y + world_generation_constants.RENDER_DISTANCE do
					local chunkPosition = vmath.vector3(chunkX, chunkY, 0)
					chunksToUnrender[tostring(chunkPosition)] = chunkPosition
				end
			end
			local unrenderLookup = Set.subtraction(chunksToUnrender, chunksToRender, "position")

			for i, chunkPosition in pairs(chunksToUnrender) do
				if unrenderLookup[tostring(chunkPosition)] then
					local chunkToUnrender = World.get_chunk_at_position(world, chunkPosition)
					if chunkToUnrender then
						for blockX, blockXColumn in pairs(chunkToUnrender.blocks) do
							for blockY, block in pairs(blockXColumn) do
								local block = Chunk.get_block_at_position(chunkToUnrender, vmath.vector3(blockX, blockY, 0))
								if block and block.url then
									go.delete(block.url)
								end
							end
						end
						chunkToUnrender.isRendered = false
					end
				end
			end
		end

		for i, chunkPosition in pairs(chunksToRender) do
			local chunkToRender = World.get_chunk_at_position(world, chunkPosition)
			if chunkToRender and not chunkToRender.isRendered then
				for blockX, blockXColumn in pairs(chunkToRender.blocks) do
					for blockY, block in pairs(blockXColumn) do
						create_block(self, block)
					end
				end
				chunkToRender.isRendered = true
			end
		end
	end
end

function mine_block(blockUrl, message)
	go.delete(blockUrl)
	
	local screenPosition = vmath.vector3(message.screen_x, message.screen_y, 0)
	local chunkPosition = position_helpers.screen_to_chunk_position(screenPosition)
	local blockPosition = position_helpers.screen_to_block_position(screenPosition)
	
	local chunk = World.get_chunk_at_position(world, chunkPosition)
	local block = Chunk.get_block_at_position(chunk, blockPosition)

	local truePosition = position_helpers.block_to_screen_position(block)
	truePosition.x = truePosition.x + math.random(-8, 8)
	local rotation = nil
	local properties = {}
	local scale = 0.5
	
	local loosePickupId = factory.create(urls.get_pickup_factory_url(block.id), truePosition, rotation, properties, scale)
	block.pickupId = loosePickupId
	World.add_loose_pickup(world, block)
end

function get_saved_world()
	local worldFileName = sys.get_save_file(config.SAVE_PATH.folder, config.SAVE_PATH.name) .. ".json"
	local savedWorldFile = io.open(worldFileName, "r")
	if savedWorldFile then
		print("Begin reading '" .. worldFileName .. "'")
		local data = savedWorldFile:read()
		print("Finished reading '" .. worldFileName .. "'")
		
		print("Begin parsing '" .. worldFileName .. "'")
		data = json_lib.parse(data)
		print("Finished parsing '" .. worldFileName .. "'")
	
		return data
	end

	return nil
end

function initialize_from_saved_world(savedWorld)
	for chunkX, chunkXColumn in pairs(savedWorld.chunks) do
		for chunkY, chunk in pairs(chunkXColumn) do
			local worldChunk = World.get_chunk_at_position(world, chunk.position)

			for blockX, blockXColumn in pairs(chunk.blocks) do
				for blockY, block in pairs(blockXColumn) do
					Chunk.add_block(worldChunk, block)
				end
			end
		end
	end
end

function initialize_new_world()
	math.randomseed(os.time())
	for chunkX, chunkXColumn in pairs(world.chunks) do
		for chunkY, chunk in pairs(chunkXColumn) do
			local blockInfo = nil
			local randomNumber = math.random()
			if chunk.position.y <= 0 and chunk.position.y > -1 then
				if randomNumber < 0.2 then
					blockInfo = item_constants.SAND
				elseif randomNumber < 0.3 then
					blockInfo = item_constants.CLAY
				else
					blockInfo = item_constants.DIRT
				end
			elseif chunk.position.y <= -1 then
				if randomNumber < 0.1 then
					blockInfo = item_constants.DIRT
				elseif randomNumber < 0.2 then
					blockInfo = item_constants.SAND
				else
					blockInfo = item_constants.STONE
				end
			end
			if blockInfo then
				for y = 0, world_generation_constants.CHUNK_SIZE - 1 do
					for x = 0, world_generation_constants.CHUNK_SIZE - 1 do
						local blockToInsert = {}
						blockToInsert.id = blockInfo.id
						blockToInsert.position = vmath.vector3(x, y, 0)
						blockToInsert.type = blockInfo.type
						
						Chunk.add_block(chunk, blockToInsert)
					end
				end
			end
		end
	end
end

function initialize_world_chunks()
	for x = -world_generation_constants.WORLD_DIMENSIONS.x, world_generation_constants.WORLD_DIMENSIONS.x do
		for y = -world_generation_constants.WORLD_DIMENSIONS.y, world_generation_constants.WORLD_DIMENSIONS.y do
			local chunkToAdd = {}
			chunkToAdd.blocks = {}
			chunkToAdd.position = vmath.vector3(x, y, 0)
			
			World.add_chunk(world, chunkToAdd)
		end
	end
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_mine_block
local handle_place_block
local handle_update_chunk_render

function handle_mine_block(self, messageId, message, sender)
	local screenPosition = vmath.vector3(message.screen_x, message.screen_y, 0)
	local miningBlockPosition = position_helpers.screen_to_block_position(screenPosition)
	local miningChunkPosition = position_helpers.screen_to_chunk_position(screenPosition)
	local chunk = World.get_chunk_at_position(world, miningChunkPosition)
	if chunk then
		local block = Chunk.get_block_at_position(chunk, miningBlockPosition)
		if block then
			mine_block(block.url, message)
			Chunk.remove_block_at_position(chunk, miningBlockPosition)
		end
	end
end

function handle_place_block(self, messageId, message, sender)
	local toolbarItem = message.toolbarItem
	if toolbarItem and toolbarItem.id ~= item_constants.NONE.id then
		local messagePosition = vmath.vector3(message.screen_x, message.screen_y, 0)
		local chunkPosition = position_helpers.screen_to_chunk_position(messagePosition)
		local chunk = World.get_chunk_at_position(world, chunkPosition)
		if chunk then
			local blockPosition = position_helpers.screen_to_block_position(messagePosition)
			if not Chunk.get_block_at_position(chunk, blockPosition) then
				local block = {
					chunk = chunk.position,
					id = toolbarItem.id,
					position = blockPosition,
					type = toolbarItem.type
				}
				if create_block(self, block) then
					toolbarItem.count = toolbarItem.count - 1
					msg.post("/player#player_script", "update_toolbar_item", toolbarItem)
				end
			end
		end
	end
end

function handle_update_chunk_render(self, messageId, message, sender)
	create_blocks_from_world(self)
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	msg.post("@render:", "clear_color", { color = vmath.vector4(0, 0, 0, 1.0) })
	initialize_world_chunks()
	local savedWorld = get_saved_world()
	if savedWorld and savedWorld.chunks then
		initialize_from_saved_world(savedWorld)
	else
		initialize_new_world()
	end
	create_blocks_from_world(self)
end

function on_message(self, messageId, message, sender)
	if messageId == hash("mine_block") then
		handle_mine_block(self, messageId, message, sender)
	elseif messageId == hash("place_block") then
		handle_place_block(self, messageId, message, sender)
	elseif messageId == hash("update_chunk_render") then
		handle_update_chunk_render(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------