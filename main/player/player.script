local config = require "modules.config"
local globals = require "modules.globals"
local helpers = require "modules.helpers"
local inventory_constants = require "modules.constants.inventory"
local item_constants = require "modules.constants.items"
local orthographic = require "orthographic.camera"
local platypus = require "platypus.platypus"
local player_constants = require "modules.constants.player"
local position_helpers = require "modules.position_helpers"
local toolbar_constants = require "modules.constants.toolbar"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"

-------------
-- Helpers --
-------------

local add_loose_pickup_to_player
local check_for_crafting_components
local update_current_chunk
local update_inventory
local update_toolbar

function add_loose_pickup_to_player(self, messageId, message, sender)
	local loosePickup = World.get_loose_pickup(world, message.other_id)
	if loosePickup then
		local function add_loose_pickup(maxSlots, container, updateFunction)
			for i = 1, maxSlots do
				local item = container[i]
				if item.id == loosePickup.id and item.count < item_constants.ITEM_INFO[item.id].stackSize then
					item.count = item.count + 1
					updateFunction()
					return true
				elseif item.id == item_constants.NONE.id then
					item.count = 1
					item.id = loosePickup.id
					item.name = item_constants.ITEM_INFO[item.id].name
					updateFunction()
					return true
				end
			end
			return false
		end
		if add_loose_pickup(toolbar_constants.TOOLBAR_MAX_SLOTS, self.toolbar, update_toolbar) then
			return true
		else
			return add_loose_pickup(inventory_constants.INVENTORY_MAX_SLOTS, self.inventory, update_inventory)
		end
	end

	return false
end

function check_for_crafting_components(self, componentsToCheck, materialsToUse, container)
	for i, item in pairs(container) do
		local component = componentsToCheck[item.id]
		if (component and not component.fulfilled) then
			local amountToTake
			local requirement = component.requirement
			if component.actual + item.count > requirement then
				amountToTake = requirement - component.actual
			else
				amountToTake = item.count
			end
			component.actual = component.actual + amountToTake
			if component.actual == component.requirement then
				component.fulfilled = true
			end

			table.insert(materialsToUse, { index = item.index, count = amountToTake })
		end
	end
end

function update_current_chunk(self)
	local screenPosition = position_helpers.player_to_screen_position(go.get_position())
	local chunkPosition = position_helpers.screen_to_chunk_position(screenPosition)

	local chunk = World.get_chunk_at_position(world, chunkPosition)
	if globals.currentChunk ~= chunk then
		globals.previousChunk = globals.currentChunk
		globals.currentChunk = chunk
		msg.post("/world#world_script", "update_chunk_render")
	end
end

function update_inventory()
	msg.post("/ui#ui", "update_inventory")
end

function update_toolbar()
	msg.post("/ui#ui", "update_toolbar")
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_craft
local handle_jump
local handle_left
local handle_left_click
local handle_right
local handle_right_click
local handle_switch_selected_toolbar_item
local handle_trigger_response
local handle_update_toolbar_item

function handle_craft(self, messageId, message, sender, recipeToCraft)
	local componentsToCheck = {}
	for id, requirement in pairs(recipeToCraft.components) do
		componentsToCheck[id] = { requirement = requirement, actual = 0, fulfilled = false }
	end

	local toolbarMaterialsToUse = {}
	check_for_crafting_components(self, componentsToCheck, toolbarMaterialsToUse, self.toolbar)

	local inventoryMaterialsToUse = {}
	check_for_crafting_components(self, componentsToCheck, inventoryMaterialsToUse, self.inventory)
	
	local canCraftRecipe = true
	for i, component in pairs(componentsToCheck) do
		if not component.fulfilled then
			print("Cannot craft "..item_constants.ITEM_INFO[recipeToCraft.itemId].name)
			canCraftRecipe = false
			break
		end
	end
	if canCraftRecipe then
		print("Can craft "..item_constants.ITEM_INFO[recipeToCraft.itemId].name)
	end
	print("Components:")
	pprint(componentsToCheck)
	print("Toolbar:")
	pprint(toolbarMaterialsToUse)
	print("Inventory:")
	pprint(inventoryMaterialsToUse)
end

function handle_jump(self, messageId, message, sender)
	if message.pressed then
		self.platypus.jump(player_constants.PLAYER_JUMP_FORCE)
	elseif message.released then
		self.platypus.abort_jump(0.5)
	end
end

function handle_left(self, messageId, message, sender)
	self.platypus.left(player_constants.PLAYER_VELOCITY.x)
end

function handle_left_click(self, messageId, message, sender)
	self.miningMessage = message
	
	if message.pressed then
		self.miningTimerHandle = timer.delay(player_constants.PLAYER_BASE_MINING_INTERVAL, true, function (self, handle, timeElapsed)
			msg.post("/world#world_script", "mine_block", self.miningMessage)
		end)
	elseif message.released then
		timer.cancel(self.miningTimerHandle)
	end
end

function handle_right(self, messageId, message, sender)
	self.platypus.right(player_constants.PLAYER_VELOCITY.x)
end

function handle_right_click(self, messageId, message, sender)
	self.placingMessage = message
	if message.pressed then
		self.placingMessage.toolbarItem = self.toolbar[self.selectedToolbarItem]
		if helpers.is_placeable(self.placingMessage.toolbarItem) and self.placingMessage.toolbarItem.id ~= item_constants.NONE.id then
			msg.post("/world#world_script", "place_block", self.placingMessage)
		end
		self.placingTimerHandle = timer.delay(player_constants.PLAYER_BASE_PLACING_INTERVAL, true, function (self, handle, timeElapsed)
			self.placingMessage.toolbarItem = self.toolbar[self.selectedToolbarItem]
			if helpers.is_placeable(self.placingMessage.toolbarItem) and self.placingMessage.toolbarItem.id ~= item_constants.NONE.id then
				msg.post("/world#world_script", "place_block", self.placingMessage)
			end
		end)
	elseif message.released then
		timer.cancel(self.placingTimerHandle)
	end
end

function handle_switch_selected_toolbar_item(self, messageId, message, sender)
	self.selectedToolbarItem = message.toolbarIndex
end

function handle_trigger_response(self, messageId, message, sender)
	if message.group == hash("pickup") then
		if add_loose_pickup_to_player(self, messageId, message, sender) then
			go.delete(message.other_id)
		end
	end
end

function handle_update_toolbar_item(self, messageId, message, sender)
	if message.count == 0 then
		message.id = item_constants.NONE.id
		message.name = item_constants.ITEM_INFO[item_constants.NONE.id].name
	end
	self.toolbar[message.index] = message
	msg.post("/ui#ui", "update_toolbar")
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	currentChunk = nil
	
	self.inventory = globals.get_inventory()
	self.miningTimerHandle = nil
	self.placingTimerHandle = nil
	self.platypus = platypus.create(config.PLATYPUS_CONFIG)
	self.selectedToolbarItem = 1
	self.toolbar = globals.get_toolbar()
	
	defos.set_cursor_visible(true)
end

function update(self, dt)
	self.platypus.update(dt)

	update_current_chunk(self)
end

function on_message(self, messageId, message, sender)
	self.platypus.on_message(messageId, message)

	if messageId == hash("jump") then
		handle_jump(self, messageId, message, sender)
	elseif messageId == hash("left") then
		handle_left(self, messageId, message, sender)
	elseif messageId == hash("left_click") then
		handle_left_click(self, messageId, message, sender)
	elseif messageId == hash("right") then
		handle_right(self, messageId, message, sender)
	elseif messageId == hash("right_click") then
		handle_right_click(self, messageId, message, sender)
	elseif messageId == hash("switch_selected_toolbar_item") then
		handle_switch_selected_toolbar_item(self, messageId, message, sender)
	elseif messageId == hash("trigger_response") then
		handle_trigger_response(self, messageId, message, sender)
	elseif messageId == hash("update_toolbar_item") then
		handle_update_toolbar_item(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------