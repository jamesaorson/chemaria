local camera_constants = require "modules.constants.camera"
local config = require "modules.config"
local globals = require "modules.globals"
local helpers = require "modules.helpers"
local input_constants = require "modules.constants.input"
local inventory_constants = require "modules.constants.inventory"
local item_constants = require "modules.constants.items"
local message_constants = require "modules.constants.messages"
local orthographic = require "orthographic.camera"
local platypus = require "platypus.platypus"
local platypus_constants = require "modules.constants.platypus"
local player_constants = require "modules.constants.player"
local position_helpers = require "modules.position_helpers"
local toolbar_constants = require "modules.constants.toolbar"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"

-------------
-- Helpers --
-------------

local add_loose_pickup_to_player
local update_crafting_ui
local update_current_chunk
local update_inventory_ui
local update_toolbar_ui

function add_loose_pickup_to_player(self, messageId, message, sender)
	local loosePickup = World.get_loose_pickup(world, message.other_id)
	if loosePickup then
		local function add_loose_pickup(container, updateFn)
			for _, item in pairs(container) do
				if item.id == loosePickup.id and item.count < item_constants.ALL_ITEMS[item.id].stackSize then
					item.count = item.count + 1
					updateFn()
					update_crafting_ui()
					return true
				elseif item.id == item_constants.NONE.id then
					item.count = 1
					item.id = loosePickup.id
					item.name = item_constants.ALL_ITEMS[item.id].name
					updateFn()
					update_crafting_ui()
					return true
				end
			end
			return false
		end
		if add_loose_pickup(self.toolbar, update_toolbar_ui) then
			return true
		else
			return add_loose_pickup(self.inventory, update_inventory_ui)
		end
	end
	return false
end

function update_crafting_ui()
	msg.post("/crafting_ui#crafting_ui", "update_recipe_list")
end

function update_current_chunk(self)
	local screenPosition = position_helpers.player_to_screen_position()
	local chunkPosition = position_helpers.screen_to_chunk_position(screenPosition)

	local chunk = World.get_chunk_at_position(world, chunkPosition)
	if globals.currentChunk ~= chunk then
		globals.previousChunk = globals.currentChunk
		globals.currentChunk = chunk
		msg.post("/world#world_script", "update_chunk_render")
	end
end

function update_inventory_ui()
	msg.post("/ui#ui", "update_inventory")
end

function update_toolbar_ui()
	msg.post("/ui#ui", "update_toolbar")
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_craft
local handle_jump
local handle_left
local handle_left_click
local handle_right
local handle_right_click
local handle_switch_selected_toolbar_item
local handle_trigger_response
local handle_update_toolbar_item

function handle_craft(self, messageId, message, sender)
	local recipeToCraft = message.recipe
	if recipeToCraft == nil then
		print("Recipe to craft was nil")
		return
	end

	local canCraftRecipe = false
	local componentsToCheck = {}
	local toolbarMaterialsToUse = {}
	local inventoryMaterialsToUse = {}
	if not recipeToCraft.needsFurnace or (recipeToCraft.needsFurnace and self.isInRangeOfFurnace) then
		canCraftRecipe = helpers.check_for_crafting_components(self, recipeToCraft, componentsToCheck, toolbarMaterialsToUse, self.toolbar)
		if not canCraftRecipe then
			canCraftRecipe = helpers.check_for_crafting_components(self, recipeToCraft, componentsToCheck, inventoryMaterialsToUse, self.inventory)
		end
	end

	local itemToCraft = item_constants.ALL_ITEMS[recipeToCraft.itemId]
	if canCraftRecipe then
		local function use_materials(container, materialsToUse)
			for _, materialToUse in pairs(materialsToUse) do
				local containerItem = container[materialToUse.index]
				containerItem.count = containerItem.count - materialToUse.count
			end
		end
		use_materials(self.toolbar, toolbarMaterialsToUse)
		use_materials(self.inventory, inventoryMaterialsToUse)
		
		local function add_to_container(container, itemToAdd)
			for _, containerItem in pairs(container) do
				if containerItem.id == item_constants.NONE.id then
					containerItem.count = 1
					containerItem.id = itemToAdd.id
					return true
				elseif containerItem.id == itemToAdd.id and containerItem.count < item_constants.ALL_ITEMS[itemToAdd.id].stackSize then
					containerItem.count = containerItem.count + 1
					return true
				end
			end
			return false
		end
		if not add_to_container(self.toolbar, itemToCraft) then
			if not add_to_container(self.inventory, itemToCraft) then
				msg.post("/world#world_script", "create_loose_pickup", { item = itemToCraft, position = go.get_position(camera_constants.CAMERA_ID) })
			end
		end
		update_crafting_ui()
		update_inventory_ui()
		update_toolbar_ui()
	else 
		print("Cannot craft " .. item_constants.ALL_ITEMS[recipeToCraft.itemId].name)
	end
	return canCraftRecipe
end

function handle_jump(self, messageId, message, sender)
	if message.pressed then
		self.platypus.jump(player_constants.PLAYER_JUMP_FORCE)
	elseif message.released then
		self.platypus.abort_jump(0.5)
	end
end

function handle_left(self, messageId, message, sender)
	self.platypus.left(player_constants.PLAYER_VELOCITY.x)
end

function handle_left_click(self, messageId, message, sender)
	self.miningMessage = message

	if message.pressed and self.placingMessage == nil then
		self.miningTimerHandle = timer.delay(player_constants.PLAYER_BASE_MINING_INTERVAL, true, function (self, handle, timeElapsed)
			msg.post("/world#world_script", "mine_block", self.miningMessage)
		end)
	elseif message.released then
		self.miningMessage = nil
		if self.miningTimerHandle ~= nil then
			timer.cancel(self.miningTimerHandle)
		end
	end
end

function handle_right(self, messageId, message, sender)
	self.platypus.right(player_constants.PLAYER_VELOCITY.x)
end

function handle_right_click(self, messageId, message, sender)
	self.placingMessage = message
	if message.pressed and self.miningMessage == nil then
		self.placingMessage.toolbarItem = self.toolbar[self.selectedToolbarItem]
		if helpers.is_placeable(self.placingMessage.toolbarItem) and self.placingMessage.toolbarItem.id ~= item_constants.NONE.id then
			msg.post("/world#world_script", "place_block", self.placingMessage)
		end
		self.placingTimerHandle = timer.delay(player_constants.PLAYER_BASE_PLACING_INTERVAL, true, function (self, handle, timeElapsed)
			self.placingMessage.toolbarItem = self.toolbar[self.selectedToolbarItem]
			if helpers.is_placeable(self.placingMessage.toolbarItem) and self.placingMessage.toolbarItem.id ~= item_constants.NONE.id then
				msg.post("/world#world_script", "place_block", self.placingMessage)
			end
		end)
	elseif message.released then
		self.placingMessage = nil
		if self.placingTimerHandle ~= nil then
			timer.cancel(self.placingTimerHandle)
		end
	end
end

function handle_switch_selected_toolbar_item(self, messageId, message, sender)
	self.selectedToolbarItem = message.toolbarIndex
end

function handle_trigger_response(self, messageId, message, sender)
	if message.group == hash("pickup") then
		if add_loose_pickup_to_player(self, messageId, message, sender) then
			go.delete(message.other_id)
		end
	elseif message.group == hash("furnace") then
		self.isInRangeOfFurnace = message.enter
	end
end

function handle_update_toolbar_item(self, messageId, message, sender)
	if message.count == 0 then
		message.id = item_constants.NONE.id
		message.name = item_constants.ALL_ITEMS[item_constants.NONE.id].name
	end
	self.toolbar[message.index] = message
	msg.post("/ui#ui", "update_toolbar")
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	globals.currentChunk = nil

	self.inventory = globals.get_inventory()
	self.miningTimerHandle = nil
	self.placingTimerHandle = nil
	self.platypus = platypus.create(platypus_constants.CONFIG)
	self.selectedToolbarItem = 1
	self.toolbar = globals.get_toolbar()
	self.craftableItems = {}
	self.inRangeOfFurnace = false

	defos.set_cursor_visible(true)
end

function update(self, dt)
	self.platypus.update(dt)

	update_current_chunk(self)
end

function on_message(self, messageId, message, sender)
	self.platypus.on_message(messageId, message)

	if messageId == message_constants.CRAFT then
		handle_craft(self, messageId, message, sender)
	elseif messageId == input_constants.JUMP then
		handle_jump(self, messageId, message, sender)
	elseif messageId == input_constants.LEFT then
		handle_left(self, messageId, message, sender)
	elseif messageId == input_constants.LEFT_CLICK then
		handle_left_click(self, messageId, message, sender)
	elseif messageId == input_constants.RIGHT then
		handle_right(self, messageId, message, sender)
	elseif messageId == input_constants.RIGHT_CLICK then
		handle_right_click(self, messageId, message, sender)
	elseif messageId == hash("switch_selected_toolbar_item") then
		handle_switch_selected_toolbar_item(self, messageId, message, sender)
	elseif messageId == hash("trigger_response") then
		handle_trigger_response(self, messageId, message, sender)
	elseif messageId == hash("update_toolbar_item") then
		handle_update_toolbar_item(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------