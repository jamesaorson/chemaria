local constants = require "modules.constants"
local platypus = require "platypus.platypus"
local position_helpers = require "modules.position_helpers"
local globals = require "modules.globals"
local orthographic = require "orthographic.camera"

require "modules.models.Block"
require "modules.models.Chunk"
require "modules.models.World"

local PLATYPUS_CONFIG = {
	collisions = {
		separation = platypus.SEPARATION_SHAPES,
		groups = {
			[hash("block")] = platypus.DIR_ALL
		},
		left = constants.PLAYER_WIDTH / 2, right = constants.PLAYER_WIDTH / 2, top = constants.PLAYER_HEIGHT / 2, bottom = constants.PLAYER_HEIGHT / 2
	},
	gravity = constants.GRAVITY,
	max_velocity = constants.PLAYER_MAX_VELOCITY,
	allow_double_jump = true,
	allow_wall_jump = false
}

currentChunk = nil
previousChunk = nil

-------------
-- Helpers --
-------------

local add_loose_pickup_to_player
local update_current_chunk

function add_loose_pickup_to_player(self, messageId, message, sender)
	local loosePickup = World.get_loose_pickup(world, message.other_id)
	if loosePickup then
		for i = 1, constants.TOOLBAR_MAX_SLOTS do
			local toolbarItem = self.toolbar[i]
			if toolbarItem.type == loosePickup.type and toolbarItem.count < constants.ALL_ITEMS[loosePickup.type].stackSize then
				toolbarItem.count = toolbarItem.count + 1
				return true
			elseif toolbarItem.type == constants.NONE.type then
				toolbarItem.count = 1
				toolbarItem.type = loosePickup.type
				msg.post("/ui#ui", "update_toolbar")
				return true
			end
		end
		for i = 1, constants.INVENTORY_MAX_SLOTS do
			local inventoryItem = self.inventory[i]
			if inventoryItem.type == loosePickup.type and inventoryItem.count < constants.ALL_ITEMS[loosePickup.type].stackSize then
				inventoryItem.count = inventoryItem.count + 1
				return true
			elseif inventoryItem.type == constants.NONE.type then
				inventoryItem.count = 1
				inventoryItem.type = loosePickup.type
				msg.post("/ui#ui", "update_inventory")
				return true
			end
		end
	end

	return false
end

function update_current_chunk(self)
	local screenPosition = position_helpers.player_to_screen_position(go.get_position())
	local chunkPosition = position_helpers.screen_to_chunk_position(screenPosition)

	local chunk = World.get_chunk_at_position(world, chunkPosition)
	if currentChunk ~= chunk then
		previousChunk = currentChunk
		currentChunk = chunk
		print(currentChunk.position)
		print()
		msg.post("/world#world_script", "update_chunk_render")
	end
end

-----------------
-- End Helpers --
-----------------


----------------------
-- Message Handlers --
----------------------

local handle_jump
local handle_left
local handle_left_click
local handle_right
local handle_right_click
local handle_switch_selected_toolbar_item
local handle_trigger_response
local handle_update_toolbar_item

function handle_jump(self, messageId, message, sender)
	if message.pressed then
		self.platypus.jump(constants.PLAYER_JUMP_FORCE)
	elseif message.released then
		self.platypus.abort_jump(0.5)
	end
end

function handle_left(self, messageId, message, sender)
	self.platypus.left(constants.PLAYER_VELOCITY.x)
end

function handle_left_click(self, messageId, message, sender)
	if message.pressed then
		self.isMining = true
		self.miningStartTime = os.clock()
	elseif message.released then
		self.isMining = false
		self.miningStartTime = nil
	else
		local miningTime = os.clock() - self.miningStartTime
		if miningTime >= constants.PLAYER_BASE_MINING_INTERVAL then
			self.miningStartTime = os.clock()
			msg.post("/world#world_script", "mine_block", message)
		end
	end
end

function handle_right(self, messageId, message, sender)
	self.platypus.right(constants.PLAYER_VELOCITY.x)
end

function handle_right_click(self, messageId, message, sender)
	if message.pressed then
		self.isPlacing = true
		self.placingStartTime = os.clock()
	elseif message.released then
		self.isPlacing = false
		self.placingStartTime = nil
	end
	if self.placingStartTime then
		local placingTime = os.clock() - self.placingStartTime
		if message.pressed or placingTime >= constants.PLAYER_BASE_PLACING_INTERVAL then
			self.placingStartTime = os.clock()
			message.toolbarItem = self.toolbar[self.selectedToolbarItem]
			if message.toolbarItem.type ~= constants.NONE.type then
				msg.post("/world#world_script", "place_block", message)
			end
		end
	end
end

function handle_switch_selected_toolbar_item(self, messageId, message, sender)
	self.selectedToolbarItem = message.toolbarIndex
end

function handle_trigger_response(self, messageId, message, sender)
	if message.group == hash("pickup") then
		if add_loose_pickup_to_player(self, messageId, message, sender) then
			go.delete(message.other_id)
		end
	end
end

function handle_update_toolbar_item(self, messageId, message, sender)
	if message.count == 0 then
		message.type = constants.NONE.type
	end
	self.toolbar[message.index] = message
	msg.post("/ui#ui", "update_toolbar")
end

--------------------------
-- End Message Handlers --
--------------------------


----------------------
-- Defold functions --
----------------------

function init(self)
	currentChunk = nil
	self.platypus = platypus.create(PLATYPUS_CONFIG)
	self.selectedToolbarItem = 1
	self.isMining = false
	self.miningStartTime = nil
	self.placingStartTime = nil
	self.inventory = globals.get_inventory()
	self.toolbar = globals.get_toolbar()
	defos.set_cursor_visible(true)
end

function update(self, dt)
	self.platypus.update(dt)

	update_current_chunk(self)
end

function on_message(self, messageId, message, sender)
	self.platypus.on_message(messageId, message)

	if messageId == hash("jump") then
		handle_jump(self, messageId, message, sender)
	elseif messageId == hash("left") then
		handle_left(self, messageId, message, sender)
	elseif messageId == hash("left_click") then
		handle_left_click(self, messageId, message, sender)
	elseif messageId == hash("right") then
		handle_right(self, messageId, message, sender)
	elseif messageId == hash("right_click") then
		handle_right_click(self, messageId, message, sender)
	elseif messageId == hash("switch_selected_toolbar_item") then
		handle_switch_selected_toolbar_item(self, messageId, message, sender)
	elseif messageId == hash("trigger_response") then
		handle_trigger_response(self, messageId, message, sender)
	elseif messageId == hash("update_toolbar_item") then
		handle_update_toolbar_item(self, messageId, message, sender)
	end
end

--------------------------
-- End Defold functions --
--------------------------